/**{\n}
 * - - - - thoughtfully generated by synapticloop gradle-plugin-java-create - - - - {\n}
 *            with the use of synapticloop templar templating language{\n}
 *                    (build.plugin.initial.gradle.templar){\n}
 */{\n}
{\n}
/**{\n}
 * We want to ensure that we are using maven local to be able to publish the{\n}
 * plugin to the local repository.  This means that you will only need to {\n}
 * invoke this file once, and then you will have a version to be able to be {\n}
 * picked up for later use{\n}
 */{\n}
buildscript {{{\n}
{\t}repositories {{{\n}
{\t}{\t}mavenLocal(){\n}
{\t}}{\n}
}{\n}
{\n}
// list all of the plugins for this project{\n}
plugins {{{\n}
{\t}id 'java'{\n}
{\t}id 'maven'{\n}
{\t}id 'maven-publish'{\n}
}{\n}
{\n}
// textual information for this project{\n}
group = '{artefact}'{\n}
archivesBaseName = '{name}'{\n}
description = """0.0.1"""{\n}
{\n}
version = '0.0.1'{\n}
{\n}
sourceCompatibility = 1.7{\n}
targetCompatibility = 1.7{\n}
{\n}
{\n}
// all of the repositories that this project will use{\n}
repositories {{{\n}
{\t}mavenLocal(){\n}
{\t}mavenCentral(){\n}
{\t}jcenter(){\n}
}{\n}
{\n}
// now for all of the dependencies - at this point we only need the gradle{\n}
// APIs, but you will need to include any dependencies here{\n}
dependencies {{{\n}
{\t}compile gradleApi(){\n}
}{\n}
{\n}
// we always want to fail on version conflict{\n}
configurations.all {{{\n}
{\t}resolutionStrategy {{{\n}
{\t}{\t}failOnVersionConflict(){\n}
{\t}}{\n}
}{\n}
{\n}
def locateJar(lib) {{{\n}
{\t}configurations.runtime.findAll {{it.getName().contains(lib)}.collect {{ it.isDirectory() ? it : zipTree(it) }{\n}
}{\n}
{\n}
task fatJar(type: Jar) {{{\n}
{\t}classifier = 'all'{\n}
{\n}
{\t}from(sourceSets.main.output) {{ include "**" }{\n}
}{\n}
{\n}
build.finalizedBy(project.tasks.fatJar){\n}
{\n}

def javaApiUrl = 'http://docs.oracle.com/javase/1.7.0/docs/api/'{\n}
def groovyApiUrl = 'http://groovy.codehaus.org/gapi/'{\n}
{\n}
tasks.withType(Javadoc) {{{\n}
{\t}options.links(javaApiUrl, groovyApiUrl){\n}
}{\n}
{\n}
task javadocJar(type: Jar, dependsOn: javadoc) {{{\n}
{\t}classifier = 'javadoc'{\n}
{\t}from 'build/docs/javadoc'{\n}
}{\n}
{\n}
task sourcesJar(type: Jar) {{{\n}
{\t}from sourceSets.main.allSource{\n}
{\t}classifier = 'sources'{\n}
}{\n}
{\n}
// this publishes the built jar to the local repository{\n}
publishing {{{\n}
{\t}publications {{{\n}
{\t}{\t}{artefact}(MavenPublication) {{{\n}
{\t}{\t}{\t}from components.java{\n}
{\t}{\t}{\t}artifact sourcesJar{\n}
{\t}{\t}{\t}artifact javadocJar{\n}
{\n}
{\t}{\t}{\t}groupId group{\n}
{\t}{\t}{\t}artifactId archivesBaseName{\n}
{\n}
{\t}{\t}{\t}pom.withXml {{{\n}
{\t}{\t}{\t}{\t}configurations.compile.resolvedConfiguration.firstLevelModuleDependencies.each {{ dep ->{\n}
{\t}{\t}{\t}{\t}{\t}asNode().dependencies[0].dependency.find {{{\n}
{\t}{\t}{\t}{\t}{\t}{\t}it.artifactId[0].text() == dep.moduleName &&{\n}
{\t}{\t}{\t}{\t}{\t}{\t}{\t}{\t}it.groupId[0].text() == dep.moduleGroup{\n}
{\t}{\t}{\t}{\t}{\t}}.scope[0].value = 'compile'{\n}
{\t}{\t}{\t}{\t}}{\n}
{\t}{\t}{\t}}{\n}
{\t}{\t}}{\n}
{\t}}{\n}
}{\n}
{\n}
